
Extended flatbuffer.Builder with extra api methods making the builder a bit 
more easy to use.    

 -single create() method builds both structs and tables

  -no need to call Start()/End() for every table/struct being built

  -no need for explicitely call Finish() for root types

  -client code is not required to order correctly a build of fieldsJ: 
   Non-inline build of a struct is fine; a nested build is fine too.

  -accept python string as a value for a flatbuffer string field, and 
   python list for a vector field

  -values for a vector field is supplied in a natural direct order, not
   reversed

  -more readable user code as it is no longer required to call into a 
   quite verbose api generated by the fb compiler ( i.e. no calls like 
   Namespace.Type.Type.FooFieldNameCreate(builder, ...). If required, 
   the original builder api can be invoked as usual.

Example:

# -------------------------------------------------------------------------

import flatbuf as flatbuffers
import MyGame.Sample.Color
import MyGame.Sample.Equipment
import MyGame.Sample.Monster
import MyGame.Sample.Vec3
import MyGame.Sample.Weapon


bldr = flatbuffers.Builder()
with bldr.create(MyGame.Sample.Monster) as orc:
    orc.add('Name', 'Orc')

    sword = bldr.create(MyGame.Sample.Weapon,
                        {'Name': 'Sword', 'Damage': 3})
    axe = bldr.create(MyGame.Sample.Weapon,
                      {'Name': 'Axe', 'Damage': 5})
    orc.add('Weapons', [sword, axe])

    orc.add('EquippedType', MyGame.Sample.Equipment.Equipment.Weapon)
    orc.add('Equipped', axe)

    pos = bldr.create(MyGame.Sample.Vec3, [1.0, 2.0, 3.0])
    orc.add('Pos', pos)
    orc.add('Hp', 300)
    orc.add('Color', MyGame.Sample.Color.Color.Red)

    MyGame.Sample.Monster.MonsterStartInventoryVector(bldr, 10)
    for i in reversed(range(0, 10)):
        bldr.PrependByte(i)
    inv = bldr.EndVector(10)

    orc.add('Inventory', inv)
    buf = orc.output()
#-------------------------------------------------------------------------

