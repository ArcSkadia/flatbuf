import sys
from collections import OrderedDict, namedtuple
from six import string_types
from types import ModuleType
from functools import partial

from flatbuffers import Builder as FlatbuffersBuilder_

__all__ = ['Builder', 'build_inline']


class BuildInline(object):
    def __init__(self, callable_, values):
        assert callable(callable_)
        assert isinstance(
            values, (list, tuple)), 'Only structs can be built inline. Struct must be created using list of values'

        self._creator = callable_
        self._values = values

    def __call__(self, builder):
        return self._creator(builder, *self._values)


build_inline = BuildInline

Target = namedtuple('Target', ['name', 'module'])


def identify(build_target):

    # flatbuffers compiler generates submodule for every table and struct.
    # The submodule contains a definition of the python class to be created.
    # The submodule and class generated to have the same name which is a flatbuffer
    # type name in idl.

    if type(build_target) == ModuleType:
        cls_name = build_target.__name__.split('.')[-1]
        module = build_target
    else:
        cls_name = build_target.__name__
        module = sys.modules[build_target.__module__]
    return Target(cls_name, module)


def is_struct(build_target):
    """    
    Return true if build_target is defined as a struct type in idl

    build_target: Target tuple
    """
    # the only way to identify a struct is to try looking up for its Create()
    # function. Table types have Add()/End() functions instead.

    return hasattr(build_target.module, 'Create' + build_target.name)


def create_vec(builder, build_target, values):

    # for vectors, compiler generates function <Tablename>Start<Fieldname>Vector
    # that is defined in TableName module

    tbl_name = build_target.module.__name__.split('.')[-1]

    create_fn = ''.join([tbl_name, 'Start', build_target.name, 'Vector'])
    start = locate(build_target.module, create_fn)

    n_elements = len(values)
    start(builder, n_elements)
    for v in reversed(values):
        builder.PrependUOffsetTRelative(v)
    return builder.EndVector(n_elements)


def locate(module, attr):

    try:
        return getattr(module, attr)
    except AttributeError as ex:
        # try to give a hint what valid field name could be
        err = str(ex)
        attr = attr.replace('_', '')
        wanted = attr.lower()
        for valid_name in dir(module):

            if wanted != valid_name.lower():
                continue

            hint = valid_name
            for n, s in enumerate(attr):
                if s != valid_name[n]:
                    field = valid_name[n:]

                    vector = 'Vector'
                    if field.endswith(vector):
                        field = field[:-len(vector)]

                    hint = '{} (field name {})'.format(hint, field)
                    break
            err += '. Did you mean {}?'.format(hint)
            break

        raise AttributeError(err)


class Builder(FlatbuffersBuilder_):
    """
    Extend flatbuffers.Builder with extra api methods making the builder a bit 
    more easy to use.    

    -single create() method builds both structs and tables

    -no need to call Start()/End() for every table/struct being built

    -no need for explicitely call Finish() for root types

    -client code is not required to order correctly a build of fieldsJ: 
     Non-inline build of a struct is fine; a nested build is fine too.

    -accept python string as a value for a flatbuffer string field, and 
     python list for a vector field

    -values for a vector field is supplied in a natural direct order, not
     reversed

    -more readable user code as it is no longer required to call into a 
     quite verbose api generated by the fb compiler ( i.e. no calls like 
     Namespace.Type.Type.FooFieldNameCreate(builder, ...). If required, 
     the original builder api can be invoked as usual.
    """

    # want to extend flatbuffers.Builder interface, not to override it
    assert not hasattr(FlatbuffersBuilder_, 'create')
    assert not hasattr(FlatbuffersBuilder_, 'finish')

    def __init__(self, initial_size=0, **kwargs):
        super(Builder, self).__init__(initial_size, **kwargs)

    def create(self, target, properties=None):
        """
        Build flatbuffer table or struct 

        The method can be used to create both a root (top-level) table and 
        a 'data member' table/struct that is used as a field value in the 
        another type. The fields can be created and added into the target 
        table in any order, and fields' build can be nested with a build 
        of the target table.  

        Parameters: 
            target: module or class reference
               Build target ( struct or table ) identify by module or class.
               Note: this is not an instance of class, but class object itself.

            properties: 
                Fields' names and values

                For a table type field, the properties must be given either 
                as dictionary or list of tuples of field name and value pairs. 

                For struct types, the properties is a list of values.
        return: 
            If properties is None, return OrderedBuild context manager object. 
            It can be used then to create and add fields using 'with' statement. 

            Otherwise, return a value representing built target. The value can 
            be added into the root table or any other table as required. 

        Code example: 

        import Example.Message
        import Example.Destination;  
        import Example.Origin; 
        import Example.Paid;

        bldr = flatbuffer.Builder()

        paid = bldr.create(Example.Paid, [1.24, 1.03]) # Paid is a struct type

        all_destinations = [ bldr.create(Example.Destination, [('location', 'London'), ('id',  42)] ), 
                             bldr.create(Example.Destination, [('location', 'London'), ('id',  123)] ) ]  

        with bldr.create(Example.Message) as msg:
            msg.add('text': 'hello')
            msg.add('payment' : paid )
            msg.add('to' : all_destinations)
            msg.add('from': bldr.create(Example.Origin, {'sender': 'me'}) )
        encoded_msg = msg.output() 
        """

        build_mgr = OrderedBuild(self, target)
        if not properties:
            return build_mgr

        target = build_mgr.target

        # struct fields are special as they must not be pre-built in advance but the build is
        # delayed until build time of their holding table ( inline build in flatbuffers slang )
        if is_struct(target):
            struct_creator = locate(target.module, 'Create' + target.name)
            return build_inline(struct_creator, properties)

        # building a table
        properties = OrderedDict(properties)  # to accept list of tuples as properties
        with build_mgr:
            for field, value in properties.iteritems():
                build_mgr.add(field, value)
        return build_mgr.result

    def finish(self, *args, **kwargs):
        super(Builder, self).Finish(*args, **kwargs)
        return self


class OrderedBuild(object):

    def __init__(self, builder, build_target):
        self.target = identify(build_target)
        self.builder = builder

    def add(self, field_name, value):

        # here only fetching a required flatbuffer api function
        # but not invoking them. The actuall build is happened
        # in  __exit__() where we start/stop the build and
        # correctly order the items.

        add_fn = ''.join([self.target.name, 'Add', field_name])
        add = locate(self.target.module, add_fn)

        if isinstance(value, BuildInline):
            self._inline_build.append((add, value))
        else:
            if isinstance(value, string_types):
                value = self.builder.CreateString(value)

            elif isinstance(value, (list, tuple)):
                value = create_vec(self.builder, Target(field_name, self.target.module), value)

            self._build.append((add, value))

    def output(self):
        self._finalize()
        return self.builder.Output()

    def __enter__(self):
        self._build = []
        self._inline_build = []
        return self

    def __exit__(self, *args):

        start = locate(self.target.module, self.target.name + 'Start')
        finish = locate(self.target.module, self.target.name + 'End')

        start(self.builder)

        # this is for inline types (structs). they must be created in the buffer now
        # when we build a target that holds them.
        for add, create_value in self._inline_build:
            value = create_value(self.builder)
            add(self.builder, value)

        # not inlined types (tables, strings) are already pre-built in advance.
        # the flatbuffers do not allow a nested build for such items
        for add, value in self._build:
            add(self.builder, value)

        self.result = finish(self.builder)

        self._build = None
        self._inline_build = None

    def _finalize(self):
        self.builder.finish(self.result)
        self._finalize = lambda: None
